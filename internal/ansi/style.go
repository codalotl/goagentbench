package ansi

import (
	"fmt"
	"strconv"
	"strings"
)

const ANSIReset = "\x1b[0m"

type StyleSet int

const (
	StyleSetUnspecified StyleSet = iota
	StyleSetOn
	StyleSetOff
)

// Style represets a set of ANSI control code styles that can be applied to text. Each value generally has three values:
//   - On (for colors, a specific color)
//   - Off (for colors, NoColor)
//   - Unspecified (for colors, nil).
//
// Note that Off values are only used in the Apply function to strip existing styles. Style DOES NOT add control tags that "normalize" styles. Codes like 22/23/24/27/29/39/49
// will not be generated by OpeningControlCodes/Wrap/Apply, even when StyleSetOff is used.
//
// This struct can be used in three ways:
//  1. someStyle.OpeningControlCodes() + "your text" + ANSIReset -- this gives you the most control
//  2. someStyle.Wrap("your text") -- mostly sugar over the above, but allows someStyle.Wrap(otherStyle.Wrap("your text")) without dup'ing reset
//  3. someStyle.Apply("<bold>your text<reset> - more text") -- applies styles to mixed-style text. Canonicalizes result.
type Style struct {
	Foreground    Color
	Background    Color
	Bold          StyleSet
	Italic        StyleSet
	Underline     StyleSet
	Overline      StyleSet
	StrikeThrough StyleSet
	Reverse       StyleSet // Color inversion

	// Faint         StyleSet - purposefully not implemented. Apparently weak support in terminals according to ChatGPT.
	// Blink         StyleSet - purposefully not implemented. Isn't supported in terminals.
}

// OpeningControlCodes returns control codes for styles that are StyleSetOn and colors that are non-NoColor. Ex: {bold:on,italic:off,fg:red,bg:nocolor}.OpeningControlCodes()
// -> "<bold><fg-red>".
func (style Style) OpeningControlCodes() string {
	var params []string

	if style.Bold == StyleSetOn {
		params = append(params, styleSetToParam(style.Bold, "1"))
	}
	if style.Italic == StyleSetOn {
		params = append(params, styleSetToParam(style.Italic, "3"))
	}
	if style.Underline == StyleSetOn {
		params = append(params, styleSetToParam(style.Underline, "4"))
	}
	if style.Overline == StyleSetOn {
		params = append(params, styleSetToParam(style.Overline, "53"))
	}
	if style.StrikeThrough == StyleSetOn {
		params = append(params, styleSetToParam(style.StrikeThrough, "9"))
	}
	if style.Reverse == StyleSetOn {
		params = append(params, styleSetToParam(style.Reverse, "7"))
	}

	var b strings.Builder
	if len(params) > 0 {
		b.WriteString("\x1b[")
		b.WriteString(strings.Join(params, ";"))
		b.WriteString("m")
	}

	if style.Foreground != nil {
		switch c := style.Foreground.(type) {
		case NoColor:
		default:
			b.WriteString(c.ANSISequence(false))
		}
	}
	if style.Background != nil {
		switch c := style.Background.(type) {
		case NoColor:
		default:
			b.WriteString(c.ANSISequence(true))
		}
	}

	return b.String()
}

// Wrap will wrap s in the style (ex: bold red), consiering only StyleSetOn styles in style (NoColor is also ignored). If any styles were applied, ensures s ends
// in a single reset. No styles are applied to the empty string. Wrap does not detect or handle resets occuring mid-string, nor do any form of canonicalization.
//
// Only use Wrap for unstyled strings, or uniformely styled strings (ex: s was previously Wrap'ed with Bold).
func (style Style) Wrap(s string) string {
	if s == "" {
		return ""
	}

	seq := style.OpeningControlCodes()
	if seq == "" {
		return s
	}

	if hasTrailingReset(s) {
		return seq + s
	}

	return seq + s + ANSIReset
}

// Apply applies style to formattedStr, which may already have ANSI styles.
//
// Nonconflicting styles in formattedStr are left in-tact (ex: if style.Bold is StyleSetUnspecified, any existing bold text in formattedStr will continue to be bold).
// If style.Foreground/Background is nil, Apply considers it Unset, and won't change the color (NoColor removes the color).
//
// Apply handles reset occuring mid-string in formattedStr. Applied styles will be re-applied after the reset.
//
// Apply always uses the `reset` code ("\x1b[0m") to transition styles. Per-style resets (ex: code 39 - reset fg color to default) are not used. However, per-style
// resets are **detected** and handled. The returned string is canonicalized to resets only (code 39 from above will never be in the returned string).
//
// Finally, Apply returns a maximally simplified string. Unnecessary codes are removed. It assumes formattedStr is a complete specification of the styles of formattedStr
// (ex: a lone reset mid-string can be removed, since nothing in formattedStr added styles for the reset to reset).
//
// Examples (using tags for ease of human reading - actually ANSI codes in Apply):
//   - {*}.Apply("") -> ""
//   - {fg:red}.Apply("hi") -> "<red>hi<reset>"
//   - {}.Apply("hello<reset> world") -> "hello world"
//   - {fg:red}.Apply("hello<reset> world") -> "<red>hello world<reset>"
//   - {fg:red}.Apply("<green>hello<reset> world") -> "<red>hello world<reset>"
//   - {fg:red}.Apply("<bold>hello<reset> world") -> "<red><bold>hello<reset><red> world<reset>"
//   - {fg:unset}.Apply("<green>hello<reset> world") -> "hello world"
//   - {bold:off,italic:set}.Apply("<bold>hello<reset> world") -> "<italic>hello world<reset>"
//   - {fg:red}.Apply("<green>hello<default-fg> world") -> "<red>hello world<reset>"
//   - {fg:red}.Apply("<bold>hello<22-normal> world") -> "<red><bold>hello<reset><red> world<reset>"
//   - {fg:nocolor}.Apply("hello world") -> "hello world"
//   - {bold:off,italic:set}.Apply("<bold>hello<22-normal> world") -> "<italic>hello world<reset>"
//   - {}.Apply("hello<22-normal> world") -> "hello world"
//   - {}.Apply("hello world<bold>") -> "hello world"
//   - {}.Apply("hello world<reset>") -> "hello world"
func (style Style) Apply(formattedStr string) string {
	if formattedStr == "" {
		return ""
	}

	var out strings.Builder
	active := defaultState()
	base := defaultState()
	wroteText := false
	resetSinceSegment := false

	i := 0
	textStart := 0
	for i < len(formattedStr) {
		if formattedStr[i] == '\x1b' && i+1 < len(formattedStr) && formattedStr[i+1] == '[' {
			if textStart < i {
				target := mergeState(base, style)
				writeSegment(formattedStr[textStart:i], &out, target, &active, &wroteText, resetSinceSegment)
				resetSinceSegment = false
			}

			rest := formattedStr[i+2:]
			endIdx := strings.IndexByte(rest, 'm')
			if endIdx == -1 {
				target := mergeState(base, style)
				writeSegment(formattedStr[i:], &out, target, &active, &wroteText, resetSinceSegment)
				return finalizeOutput(out.String(), active, wroteText)
			}

			content := rest[:endIdx]
			params, ok := parseSGRParameters(content)
			if ok {
				var sawReset bool
				base, sawReset = applyParams(base, params)
				resetSinceSegment = resetSinceSegment || sawReset
			} else {
				target := mergeState(base, style)
				writeSegment(formattedStr[i:i+2+endIdx+1], &out, target, &active, &wroteText, resetSinceSegment)
				resetSinceSegment = false
			}

			i = i + 2 + endIdx + 1
			textStart = i
			continue
		}
		i++
	}

	if textStart < len(formattedStr) {
		target := mergeState(base, style)
		writeSegment(formattedStr[textStart:], &out, target, &active, &wroteText, resetSinceSegment)
	}
	return finalizeOutput(out.String(), active, wroteText)
}

func styleSetToParam(set StyleSet, onVal string) string {
	if set == StyleSetOn {
		return onVal
	}
	return ""
}

func parseSGRParameters(content string) ([]int, bool) {
	if content == "" {
		return []int{0}, true
	}

	parts := strings.Split(content, ";")
	params := make([]int, 0, len(parts))
	for _, p := range parts {
		if p == "" {
			params = append(params, 0)
			continue
		}
		val, err := strconv.Atoi(p)
		if err != nil {
			return nil, false
		}
		params = append(params, val)
	}
	return params, true
}

type state struct {
	bold          bool
	italic        bool
	underline     bool
	overline      bool
	strikeThrough bool
	reverse       bool
	fg            Color
	bg            Color
}

func defaultState() state {
	return state{}
}

func mergeState(base state, style Style) state {
	merged := base

	switch style.Bold {
	case StyleSetOn:
		merged.bold = true
	case StyleSetOff:
		merged.bold = false
	}

	switch style.Italic {
	case StyleSetOn:
		merged.italic = true
	case StyleSetOff:
		merged.italic = false
	}

	switch style.Underline {
	case StyleSetOn:
		merged.underline = true
	case StyleSetOff:
		merged.underline = false
	}

	switch style.Overline {
	case StyleSetOn:
		merged.overline = true
	case StyleSetOff:
		merged.overline = false
	}

	switch style.StrikeThrough {
	case StyleSetOn:
		merged.strikeThrough = true
	case StyleSetOff:
		merged.strikeThrough = false
	}

	switch style.Reverse {
	case StyleSetOn:
		merged.reverse = true
	case StyleSetOff:
		merged.reverse = false
	}

	if style.Foreground != nil {
		if _, ok := style.Foreground.(NoColor); ok {
			merged.fg = nil
		} else {
			merged.fg = style.Foreground
		}
	}

	if style.Background != nil {
		if _, ok := style.Background.(NoColor); ok {
			merged.bg = nil
		} else {
			merged.bg = style.Background
		}
	}

	return merged
}

func (s state) equals(other state) bool {
	return s.bold == other.bold &&
		s.italic == other.italic &&
		s.underline == other.underline &&
		s.overline == other.overline &&
		s.strikeThrough == other.strikeThrough &&
		s.reverse == other.reverse &&
		colorsEqual(s.fg, other.fg) &&
		colorsEqual(s.bg, other.bg)
}

func (s state) isDefault() bool {
	return s.equals(defaultState())
}

func applyParams(s state, params []int) (state, bool) {
	if len(params) == 0 {
		return s, false
	}

	sawReset := false

	for i := 0; i < len(params); i++ {
		p := params[i]
		switch {
		case p == 0:
			s = defaultState()
			sawReset = true
		case p == 1:
			s.bold = true
		case p == 22:
			s.bold = false
			sawReset = true
		case p == 3:
			s.italic = true
		case p == 23:
			s.italic = false
			sawReset = true
		case p == 4:
			s.underline = true
		case p == 24:
			s.underline = false
			sawReset = true
		case p == 7:
			s.reverse = true
		case p == 27:
			s.reverse = false
			sawReset = true
		case p == 9:
			s.strikeThrough = true
		case p == 29:
			s.strikeThrough = false
			sawReset = true
		case p == 53:
			s.overline = true
		case p == 55:
			s.overline = false
			sawReset = true
		case p == 39:
			s.fg = nil
			sawReset = true
		case p == 49:
			s.bg = nil
			sawReset = true
		case isForegroundColor(p):
			if fg := colorFromCode(p); fg != nil {
				s.fg = fg
			}
		case isBackgroundColor(p):
			s.bg = colorFromCode(p)
		case p == 38:
			if color, advanced := parseExtendedColor(params, i); advanced {
				s.fg = color
				i = skipExtendedAdvance(params, i)
			}
		case p == 48:
			if color, advanced := parseExtendedColor(params, i); advanced {
				s.bg = color
				i = skipExtendedAdvance(params, i)
			}
		}
	}
	return s, sawReset
}

func isForegroundColor(p int) bool {
	return (p >= 30 && p <= 37) || (p >= 90 && p <= 97)
}

func isBackgroundColor(p int) bool {
	return (p >= 40 && p <= 47) || (p >= 100 && p <= 107)
}

func colorFromCode(p int) Color {
	var idx int
	switch {
	case p >= 30 && p <= 37:
		idx = p - 30
	case p >= 90 && p <= 97:
		idx = p - 90 + 8
	case p >= 40 && p <= 47:
		idx = p - 40
	case p >= 100 && p <= 107:
		idx = p - 100 + 8
	default:
		return nil
	}
	return ANSIColor(idx)
}

func parseExtendedColor(params []int, idx int) (Color, bool) {
	if idx+1 >= len(params) {
		return nil, false
	}
	mode := params[idx+1]
	if mode == 5 {
		if idx+2 >= len(params) {
			return nil, false
		}
		return ANSI256Color(params[idx+2]), true
	}
	if mode == 2 {
		if idx+4 >= len(params) {
			return nil, false
		}
		r := uint8(params[idx+2])
		g := uint8(params[idx+3])
		b := uint8(params[idx+4])
		return NewRGBColor(r, g, b), true
	}
	return nil, false
}

func skipExtendedAdvance(params []int, idx int) int {
	if idx+1 >= len(params) {
		return idx
	}
	mode := params[idx+1]
	if mode == 5 {
		if idx+2 < len(params) {
			return idx + 2
		}
		return len(params) - 1
	}
	if mode == 2 {
		if idx+4 < len(params) {
			return idx + 4
		}
		return len(params) - 1
	}
	return idx + 1
}

func writeSegment(segment string, out *strings.Builder, target state, active *state, wroteText *bool, forceReset bool) {
	if segment == "" {
		return
	}
	writeTransition(out, target, active, forceReset)
	out.WriteString(segment)
	*wroteText = true
}

func writeTransition(out *strings.Builder, target state, active *state, forceReset bool) {
	if active.equals(target) {
		return
	}

	needReset := forceReset ||
		(active.bold && !target.bold) ||
		(active.italic && !target.italic) ||
		(active.underline && !target.underline) ||
		(active.overline && !target.overline) ||
		(active.strikeThrough && !target.strikeThrough) ||
		(active.reverse && !target.reverse) ||
		(active.fg != nil && !colorsEqual(active.fg, target.fg) && target.fg == nil) ||
		(active.bg != nil && !colorsEqual(active.bg, target.bg) && target.bg == nil)

	if needReset {
		out.WriteString(ANSIReset)
		*active = defaultState()
	}

	if target.isDefault() {
		return
	}

	params := make([]int, 0, 6)
	if !active.bold && target.bold {
		params = append(params, 1)
	}
	if !active.italic && target.italic {
		params = append(params, 3)
	}
	if !active.underline && target.underline {
		params = append(params, 4)
	}
	if !active.overline && target.overline {
		params = append(params, 53)
	}
	if !active.strikeThrough && target.strikeThrough {
		params = append(params, 9)
	}
	if !active.reverse && target.reverse {
		params = append(params, 7)
	}

	if len(params) > 0 {
		out.WriteString(buildSGR(params))
	}

	if !colorsEqual(active.fg, target.fg) && target.fg != nil {
		out.WriteString(target.fg.ANSISequence(false))
	}

	if !colorsEqual(active.bg, target.bg) && target.bg != nil {
		out.WriteString(target.bg.ANSISequence(true))
	}

	*active = target
}

func colorsEqual(a, b Color) bool {
	if a == nil && b == nil {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	ar, ag, ab, aa := a.RGBA()
	br, bg, bb, ba := b.RGBA()
	return ar == br && ag == bg && ab == bb && aa == ba && colorTypesEqual(a, b)
}

func colorTypesEqual(a, b Color) bool {
	return fmt.Sprintf("%T", a) == fmt.Sprintf("%T", b)
}

func finalizeOutput(s string, active state, wroteText bool) string {
	if !wroteText {
		return s
	}
	if active.isDefault() {
		return s
	}
	return s + ANSIReset
}

func buildSGR(params []int) string {
	if len(params) == 0 {
		return ""
	}
	strs := make([]string, len(params))
	for i, p := range params {
		strs[i] = strconv.Itoa(p)
	}
	return "\x1b[" + strings.Join(strs, ";") + "m"
}

func hasTrailingReset(s string) bool {
	return strings.HasSuffix(s, ANSIReset) || strings.HasSuffix(s, "\x1b[m")
}
